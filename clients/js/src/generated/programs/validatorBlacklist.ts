/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedDelegateInstruction,
  type ParsedInitConfigInstruction,
  type ParsedUndelegateInstruction,
  type ParsedUnvoteAddInstruction,
  type ParsedUnvoteRemoveInstruction,
  type ParsedUpdateConfigAdminInstruction,
  type ParsedUpdateConfigInstruction,
  type ParsedVoteAddInstruction,
  type ParsedVoteRemoveInstruction,
} from '../instructions';

export const VALIDATOR_BLACKLIST_PROGRAM_ADDRESS =
  'C7662BVQCwLuorurd8vXohNczQuMHMhDqZ4JcMMge77d' as Address<'C7662BVQCwLuorurd8vXohNczQuMHMhDqZ4JcMMge77d'>;

export enum ValidatorBlacklistAccount {
  Blacklist,
  Config,
  Delegation,
  VoteAddToBlacklist,
  VoteRemoveFromBlacklist,
}

export function identifyValidatorBlacklistAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): ValidatorBlacklistAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([131, 9, 212, 250, 58, 186, 247, 3])
      ),
      0
    )
  ) {
    return ValidatorBlacklistAccount.Blacklist;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([155, 12, 170, 224, 30, 250, 204, 130])
      ),
      0
    )
  ) {
    return ValidatorBlacklistAccount.Config;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([237, 90, 140, 159, 124, 255, 243, 80])
      ),
      0
    )
  ) {
    return ValidatorBlacklistAccount.Delegation;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([163, 175, 255, 0, 25, 228, 211, 220])
      ),
      0
    )
  ) {
    return ValidatorBlacklistAccount.VoteAddToBlacklist;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([86, 193, 80, 165, 129, 161, 46, 231])
      ),
      0
    )
  ) {
    return ValidatorBlacklistAccount.VoteRemoveFromBlacklist;
  }
  throw new Error(
    'The provided account could not be identified as a validatorBlacklist account.'
  );
}

export enum ValidatorBlacklistInstruction {
  Delegate,
  InitConfig,
  Undelegate,
  UnvoteAdd,
  UnvoteRemove,
  UpdateConfig,
  UpdateConfigAdmin,
  VoteAdd,
  VoteRemove,
}

export function identifyValidatorBlacklistInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): ValidatorBlacklistInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([90, 147, 75, 178, 85, 88, 4, 137])
      ),
      0
    )
  ) {
    return ValidatorBlacklistInstruction.Delegate;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([23, 235, 115, 232, 168, 96, 1, 231])
      ),
      0
    )
  ) {
    return ValidatorBlacklistInstruction.InitConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([131, 148, 180, 198, 91, 104, 42, 238])
      ),
      0
    )
  ) {
    return ValidatorBlacklistInstruction.Undelegate;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([108, 78, 69, 192, 186, 112, 33, 130])
      ),
      0
    )
  ) {
    return ValidatorBlacklistInstruction.UnvoteAdd;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([89, 157, 127, 31, 39, 67, 197, 174])
      ),
      0
    )
  ) {
    return ValidatorBlacklistInstruction.UnvoteRemove;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([29, 158, 252, 191, 10, 83, 219, 99])
      ),
      0
    )
  ) {
    return ValidatorBlacklistInstruction.UpdateConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([30, 254, 195, 1, 169, 26, 214, 39])
      ),
      0
    )
  ) {
    return ValidatorBlacklistInstruction.UpdateConfigAdmin;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([182, 101, 189, 107, 95, 99, 36, 137])
      ),
      0
    )
  ) {
    return ValidatorBlacklistInstruction.VoteAdd;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([203, 107, 232, 11, 28, 70, 64, 36])
      ),
      0
    )
  ) {
    return ValidatorBlacklistInstruction.VoteRemove;
  }
  throw new Error(
    'The provided instruction could not be identified as a validatorBlacklist instruction.'
  );
}

export type ParsedValidatorBlacklistInstruction<
  TProgram extends string = 'C7662BVQCwLuorurd8vXohNczQuMHMhDqZ4JcMMge77d',
> =
  | ({
      instructionType: ValidatorBlacklistInstruction.Delegate;
    } & ParsedDelegateInstruction<TProgram>)
  | ({
      instructionType: ValidatorBlacklistInstruction.InitConfig;
    } & ParsedInitConfigInstruction<TProgram>)
  | ({
      instructionType: ValidatorBlacklistInstruction.Undelegate;
    } & ParsedUndelegateInstruction<TProgram>)
  | ({
      instructionType: ValidatorBlacklistInstruction.UnvoteAdd;
    } & ParsedUnvoteAddInstruction<TProgram>)
  | ({
      instructionType: ValidatorBlacklistInstruction.UnvoteRemove;
    } & ParsedUnvoteRemoveInstruction<TProgram>)
  | ({
      instructionType: ValidatorBlacklistInstruction.UpdateConfig;
    } & ParsedUpdateConfigInstruction<TProgram>)
  | ({
      instructionType: ValidatorBlacklistInstruction.UpdateConfigAdmin;
    } & ParsedUpdateConfigAdminInstruction<TProgram>)
  | ({
      instructionType: ValidatorBlacklistInstruction.VoteAdd;
    } & ParsedVoteAddInstruction<TProgram>)
  | ({
      instructionType: ValidatorBlacklistInstruction.VoteRemove;
    } & ParsedVoteRemoveInstruction<TProgram>);
